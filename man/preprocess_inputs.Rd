% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/preprocess.R
\name{preprocess_inputs}
\alias{preprocess_inputs}
\alias{select_keys_and}
\alias{summarize_by_keys}
\alias{nest_by_keys}
\alias{pack_along_keys}
\alias{pivot_wider_by_keys}
\alias{pivot_longer_by_keys}
\title{Preprocess powerjoin inputs}
\usage{
select_keys_and(.data, ...)

summarize_by_keys(.data, ...)

nest_by_keys(.data, ..., name = NULL)

pack_along_keys(.data, ..., name)

pivot_wider_by_keys(
  data,
  names_from = name,
  names_prefix = "",
  names_sep = "_",
  names_glue = NULL,
  names_sort = FALSE,
  names_repair = "check_unique",
  values_from = value,
  values_fill = NULL,
  values_fn = NULL,
  ...
)

pivot_longer_by_keys(
  data,
  cols,
  names_to = "name",
  names_prefix = NULL,
  names_sep = NULL,
  names_pattern = NULL,
  names_ptypes = list(),
  names_transform = list(),
  names_repair = "check_unique",
  values_to = "value",
  values_drop_na = FALSE,
  values_ptypes = list(),
  values_transform = list(),
  ...
)
}
\arguments{
\item{.data}{A data frame to pivot.}

\item{...}{Additional arguments passed on to methods.}

\item{data}{A data frame to pivot.}

\item{names_from}{<\code{\link[tidyr:tidyr_tidy_select]{tidy-select}}> A pair of
arguments describing which column (or columns) to get the name of the
output column (\code{names_from}), and which column (or columns) to get the
cell values from (\code{values_from}).

If \code{values_from} contains multiple values, the value will be added to the
front of the output column.}

\item{names_prefix}{String added to the start of every variable name. This is
particularly useful if \code{names_from} is a numeric vector and you want to
create syntactic variable names.}

\item{names_sep}{If \code{names_from} or \code{values_from} contains multiple
variables, this will be used to join their values together into a single
string to use as a column name.}

\item{names_glue}{Instead of \code{names_sep} and \code{names_prefix}, you can supply
a glue specification that uses the \code{names_from} columns (and special
\code{.value}) to create custom column names.}

\item{names_sort}{Should the column names be sorted? If \code{FALSE}, the default,
column names are ordered by first appearance.}

\item{names_repair}{What happens if the output has invalid column names?
The default, \code{"check_unique"} is to error if the columns are duplicated.
Use \code{"minimal"} to allow duplicates in the output, or \code{"unique"} to
de-duplicated by adding numeric suffixes. See \code{\link[vctrs:vec_as_names]{vctrs::vec_as_names()}}
for more options.}

\item{values_from}{<\code{\link[tidyr:tidyr_tidy_select]{tidy-select}}> A pair of
arguments describing which column (or columns) to get the name of the
output column (\code{names_from}), and which column (or columns) to get the
cell values from (\code{values_from}).

If \code{values_from} contains multiple values, the value will be added to the
front of the output column.}

\item{values_fill}{Optionally, a (scalar) value that specifies what each
\code{value} should be filled in with when missing.

This can be a named list if you want to apply different aggregations
to different value columns.}

\item{values_fn}{Optionally, a function applied to the \code{value} in each cell
in the output. You will typically use this when the combination of
\code{id_cols} and \code{value} column does not uniquely identify an observation.

This can be a named list if you want to apply different aggregations
to different value columns.}

\item{cols}{<\code{\link[tidyr:tidyr_tidy_select]{tidy-select}}> Columns to pivot into
longer format.}

\item{names_to}{A string specifying the name of the column to create
from the data stored in the column names of \code{data}.

Can be a character vector, creating multiple columns, if \code{names_sep}
or \code{names_pattern} is provided. In this case, there are two special
values you can take advantage of:
\itemize{
\item \code{NA} will discard that component of the name.
\item \code{.value} indicates that component of the name defines the name of the
column containing the cell values, overriding \code{values_to}.
}}

\item{names_pattern}{If \code{names_to} contains multiple values,
these arguments control how the column name is broken up.

\code{names_sep} takes the same specification as \code{\link[tidyr:separate]{separate()}}, and can either
be a numeric vector (specifying positions to break on), or a single string
(specifying a regular expression to split on).

\code{names_pattern} takes the same specification as \code{\link[tidyr:extract]{extract()}}, a regular
expression containing matching groups (\verb{()}).

If these arguments do not give you enough control, use
\code{pivot_longer_spec()} to create a spec object and process manually as
needed.}

\item{names_ptypes}{A list of column name-prototype pairs.
A prototype (or ptype for short) is a zero-length vector (like \code{integer()}
or \code{numeric()}) that defines the type, class, and attributes of a vector.
Use these arguments if you want to confirm that the created columns are
the types that you expect. Note that if you want to change (instead of confirm)
the types of specific columns, you should use \code{names_transform} or
\code{values_transform} instead.}

\item{names_transform}{A list of column name-function pairs.
Use these arguments if you need to change the types of specific columns.
For example, \code{names_transform = list(week = as.integer)} would convert
a character variable called \code{week} to an integer.

If not specified, the type of the columns generated from \code{names_to} will
be character, and the type of the variables generated from \code{values_to}
will be the common type of the input columns used to generate them.}

\item{values_to}{A string specifying the name of the column to create
from the data stored in cell values. If \code{names_to} is a character
containing the special \code{.value} sentinel, this value will be ignored,
and the name of the value column will be derived from part of the
existing column names.}

\item{values_drop_na}{If \code{TRUE}, will drop rows that contain only \code{NA}s
in the \code{value_to} column. This effectively converts explicit missing values
to implicit missing values, and should generally be used only when missing
values in \code{data} were created by its structure.}

\item{values_ptypes}{A list of column name-prototype pairs.
A prototype (or ptype for short) is a zero-length vector (like \code{integer()}
or \code{numeric()}) that defines the type, class, and attributes of a vector.
Use these arguments if you want to confirm that the created columns are
the types that you expect. Note that if you want to change (instead of confirm)
the types of specific columns, you should use \code{names_transform} or
\code{values_transform} instead.}

\item{values_transform}{A list of column name-function pairs.
Use these arguments if you need to change the types of specific columns.
For example, \code{names_transform = list(week = as.integer)} would convert
a character variable called \code{week} to an integer.

If not specified, the type of the columns generated from \code{names_to} will
be character, and the type of the variables generated from \code{values_to}
will be the common type of the input columns used to generate them.}
}
\description{
These functions are named after the tidyverse functions \code{select}, \code{summarize},
\code{nest}, \code{pack}, \code{pivot_wider} and \code{pivot_longer} and are designed to avoid
repetition of key columns when preprocessing the data for a join. They should
only be used in the \code{x} and \code{y} arguments of {powerjoin} join functions. No
further transformation should be applied on top of them.
}
\details{
Unlike their tidyverse counterparts these just add an attribute to the input and
don't reshape it. The join function then preprocesses the inputs using these
attributes and the keys.
}
